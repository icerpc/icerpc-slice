// Copyright (c) ZeroC, Inc.

[cs::namespace("ZeroC.Slice.Compiler")]
module Compiler

/// A unique identifier for a Slice entity, typically a fully-scoped identifier.
/// For example: 'MyOuterModule::MyInnerModule::MyInterface::MyOperation::MyParameter'.
typealias EntityId = string

/// A unique identifier for a Slice type or type alias, typically a fully-scoped identifier.
/// For example: 'MyOuterModule::MyInnerModule::MyStruct'.
/// A type ID can also refer to a built-in primitive type, such as 'int32' or 'string'.
/// For anonymous types (sequences, dictionaries, results), the type ID is a normalized name of the anonymous type,
/// such as 'Sequence<int32>' or 'Dictionary<string, MyModule::MyStruct>'. Its scope is the file in which it is defined,
/// unlike the other type IDs which have global scope.
/// Note: a type ID is an entity ID, but not vice versa.
typealias TypeId = string

struct EntityInfo {
    identifier: string
    tag(0) attributes: Sequence<Attribute>?
    tag(1) comment: DocComment?
}

struct Module {
    identifier: string
    tag(0) attributes: Sequence<Attribute>?
}

struct Struct {
    entityInfo: EntityInfo
    isCompact: bool
    fields: Sequence<Field>
}

struct Field {
    entityInfo: EntityInfo
    \tag: varint32?
    typeId: TypeId
    typeIsOptional: bool
    tag(0) typeAttributes: Sequence<Attribute>?
}

struct Interface {
    entityInfo: EntityInfo
    bases: Sequence<EntityId>
    operations: Sequence<Operation>
}

struct Operation {
    entityInfo: EntityInfo
    isIdempotent: bool
    parameters: Sequence<Field>
    hasStreamedParameter: bool
    returnType: Sequence<Field>
    hasStreamedReturn: bool
}

struct Enum {
    entityInfo: EntityInfo
    isCompact: bool
    isUnchecked: bool
    underlying: TypeId?
    enumerators: Sequence<Enumerator>
}

struct Enumerator {
    entityInfo: EntityInfo
    value: Discriminant
    fields: Sequence<Field>?
}

struct Discriminant {
    absoluteValue: uint64
    isPositive: bool
}

struct CustomType {
    entityInfo: EntityInfo
}

struct TypeAlias {
    entityInfo: EntityInfo
    underlying: TypeId
    tag(0) underlyingAttributes: Sequence<Attribute>?
}

struct SequenceType {
    /// The type ID of the sequence type. Starts with 'Sequence<' and ends with '>'.
    typeId: TypeId
    elementType: TypeId
}

struct DictionaryType {
    /// The type ID of the dictionary type. Starts with 'Dictionary<' and ends with '>'.
    typeId: TypeId
    keyType: TypeId
    valueType: TypeId
}

struct ResultType {
    /// The type ID of the result type. Starts with 'Result<' and ends with '>'.
    typeId: TypeId
    successType: TypeId
    failureType: TypeId
}

struct Attribute {
    directive: string
    args: Sequence<string>
}
