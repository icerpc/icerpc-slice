// Copyright (c) ZeroC, Inc.

[cs::namespace("ZeroC.Slice.Compiler")]
module Compiler

/// A unique identifier for a Slice entity, typically a fully-scoped identifier.
/// For example: 'MyOuterModule::MyInnerModule::MyInterface::MyOperation::MyParameter'.
typealias EntityId = string

struct EntityInfo {
    identifier: string
    tag(0) attributes: Sequence<Attribute>?
    tag(1) comment: DocComment?
}

struct Module {
    identifier: string
    tag(0) attributes: Sequence<Attribute>?
}

struct Struct {
    entityInfo: EntityInfo
    fields: Sequence<Field>
    isCompact: bool
    isSlice1Only: bool
}

struct Class {
    entityInfo: EntityInfo
    fields: Sequence<Field>
    compactId: int32?
    base: EntityId?
}

struct Exception {
    entityInfo: EntityInfo
    fields: Sequence<Field>
    base: EntityId?
}

struct Field {
    entityInfo: EntityInfo
    dataType: TypeRef
    \tag: varint32?
}

struct Interface {
    entityInfo: EntityInfo
    operations: Sequence<Operation>
    bases: Sequence<EntityId>
}

struct Operation {
    entityInfo: EntityInfo
    parameters: Sequence<Field>
    hasStreamedParameter: bool
    returnType: Sequence<Field>
    hasStreamedReturn: bool
    exceptionSpecification: Sequence<EntityId>
    isIdempotent: bool
}

struct Enum {
    entityInfo: EntityInfo
    enumerators: Sequence<Enumerator>
    underlying: Primitive?
    isCompact: bool
    isUnchecked: bool
}

struct Enumerator {
    entityInfo: EntityInfo
    value: Discriminant
    fields: Sequence<Field>?
}

struct Discriminant {
    absoluteValue: uint64
    isPositive: bool
}

struct CustomType {
    entityInfo: EntityInfo
}

struct TypeAlias {
    entityInfo: EntityInfo
    underlying: TypeRef
}

enum AnonymousType {
    SequenceType(v: SequenceType)
    DictionaryType(v: DictionaryType)
    ResultType(v: ResultType)
}

struct SequenceType {
    elementType: TypeRef
}

struct DictionaryType {
    keyType: TypeRef
    valueType: TypeRef
}

struct ResultType {
    successType: TypeRef
    failureType: TypeRef
}

unchecked enum Primitive : uint8 {
    Bool
    Int8
    UInt8
    Int16
    UInt16
    Int32
    UInt32
    VarInt32
    VarUInt32
    Int64
    UInt64
    VarInt62
    VarUInt62
    Float32
    Float64
    String
    \AnyClass
}

struct TypeRef {
    value: TypeRefDefinition
    isOptional: bool
    tag(0) attributes: Sequence<Attribute>?
}

enum TypeRefDefinition {
    Definition(v: EntityId)
    Primitive(v: Primitive)
    Anonymous(v: varuint62)
}

struct Attribute {
    directive: string
    args: Sequence<string>
}
