// Copyright (c) ZeroC, Inc.

[cs::namespace("ZeroC.Slice.Compiler")]
module Compiler

/// A unique identifier for a Slice entity, typically a fully-scoped identifier.
/// For example: 'MyOuterModule::MyInnerModule::MyInterface::MyOperation::MyParameter'.
typealias EntityId = string

/// A unique identifier for a Slice type or type alias, typically a fully-scoped identifier.
/// For example: 'MyOuterModule::MyInnerModule::MyStruct'.
/// A type ID can also refer to a built-in primitive type, such as 'int32' or 'string'.
/// For anonymous types (sequences, dictionaries, results), the type ID is a normalized name of the anonymous type,
/// such as 'Sequence<int32>' or 'Dictionary<string, MyModule::MyStruct>'. Its scope is the file in which it is defined,
/// unlike the other type IDs which have global scope.
/// Note: a type ID is an entity ID, but not vice versa.
typealias TypeId = string

struct EntityInfo {
    identifier: string
    tag(0) attributes: Sequence<Attribute>?
    tag(1) comment: DocComment?
}

struct Module {
    identifier: string
    tag(0) attributes: Sequence<Attribute>?
}

struct Struct {
    entityInfo: EntityInfo
    fields: Sequence<Field>
    isCompact: bool
    isSlice1Only: bool
}

struct Class {
    entityInfo: EntityInfo
    fields: Sequence<Field>
    compactId: int32?
    base: EntityId?
}

struct Exception {
    entityInfo: EntityInfo
    fields: Sequence<Field>
    base: EntityId?
}

struct Field {
    entityInfo: EntityInfo
    type: TypeId
    typeIsOptional: bool
    tag(0) typeAttributes: Sequence<Attribute>?
    \tag: varint32?
}

struct Interface {
    entityInfo: EntityInfo
    operations: Sequence<Operation>
    bases: Sequence<EntityId>
}

struct Operation {
    entityInfo: EntityInfo
    parameters: Sequence<Field>
    hasStreamedParameter: bool
    returnType: Sequence<Field>
    hasStreamedReturn: bool
    exceptionSpecification: Sequence<EntityId>
    isIdempotent: bool
}

struct Enum {
    entityInfo: EntityInfo
    enumerators: Sequence<Enumerator>
    underlying: Primitive?
    isCompact: bool
    isUnchecked: bool
}

struct Enumerator {
    entityInfo: EntityInfo
    value: Discriminant
    fields: Sequence<Field>?
}

struct Discriminant {
    absoluteValue: uint64
    isPositive: bool
}

struct CustomType {
    entityInfo: EntityInfo
}

struct TypeAlias {
    entityInfo: EntityInfo
    underlying: TypeId
    tag(0) underlyingAttributes: Sequence<Attribute>?
}

struct SequenceType {
    elementType: TypeId
}

struct DictionaryType {
    keyType: TypeId
    valueType: TypeId
}

struct ResultType {
    successType: TypeId
    failureType: TypeId
}

struct Attribute {
    directive: string
    args: Sequence<string>
}
